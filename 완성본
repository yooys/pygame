import pygame
import random
import math
import sys

pygame.init()

# í™”ë©´ ì„¤ì •
WIDTH, HEIGHT = 800, 600
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Parry Game - Meteor Trail")

# ìƒ‰ìƒ
WHITE = (255, 255, 255)
RED = (255, 50, 50)
YELLOW = (255, 255, 0)

font = pygame.font.SysFont(None, 36)
big_font = pygame.font.SysFont(None, 72)

# ë¦¬ì†ŒìŠ¤ ë¡œë“œ
background = pygame.image.load("ìš°ì£¼ë°°ê²½1.PNG")
background = pygame.transform.scale(background, (WIDTH, HEIGHT))

meteor_image = pygame.image.load("ìš´ì„.png").convert_alpha()
meteor_image = pygame.transform.scale(meteor_image, (32, 32))

earth_image = pygame.image.load("ì§€êµ¬.png").convert_alpha()
player_size = 50
earth_image = pygame.transform.scale(earth_image, (player_size, player_size))

# ìƒìˆ˜
SPAWN_INTERVAL = 1000
SPEED_INCREASE_INTERVAL = 10000
SPECIAL_PROJECTILE_SPEED_RANGE = (2, 3)

# ì „ì—­ ìƒíƒœ ë³€ìˆ˜
projectiles = []
PROJECTILE_SPEED = 4
last_spawn_time = 0
last_speed_increase_time = 0
last_parry_change_time = 0

parry_range = 120
base_parry_range = parry_range
range_reduced = False
parry_color = (255, 255, 0)
shake_start_time = 0
SHAKE_DURATION = 500
SHAKE_INTENSITY = 10

score = 0
hp = 5
last_space_pressed = False
PARRY_COOLDOWN = 200
last_parry_time = 0

special_event_triggered = False

# í”Œë ˆì´ì–´ ìœ„ì¹˜
player_pos = [WIDTH // 2, HEIGHT // 2]
player_radius = player_size // 2

# ìƒíƒœ í”Œë˜ê·¸ / íƒ€ì´ë¨¸
start_time = pygame.time.get_ticks()
running = True
game_cleared = False
game_over = False

clock = pygame.time.Clock()

# ë²„íŠ¼ ê·¸ë¦¬ê¸° í•¨ìˆ˜
def draw_button(text, x, y, w, h, color, hover_color, mouse_pos):
    rect = pygame.Rect(x, y, w, h)
    is_hover = rect.collidepoint(mouse_pos)
    pygame.draw.rect(screen, hover_color if is_hover else color, rect, border_radius=10)
    label = font.render(text, True, WHITE)
    screen.blit(label, (x + w//2 - label.get_width()//2, y + h//2 - label.get_height()//2))
    return rect

# ì™„ì „ ì´ˆê¸°í™” í•¨ìˆ˜ 
def restart_game():
    global projectiles, PROJECTILE_SPEED, last_spawn_time, last_speed_increase_time
    global last_parry_change_time, parry_range, base_parry_range, range_reduced, parry_color
    global score, hp, last_space_pressed, last_parry_time, special_event_triggered
    global start_time, game_cleared, game_over, shake_start_time
    global player_pos

    # ë¹ˆ ë¦¬ìŠ¤íŠ¸ ë° ìƒíƒœ ì´ˆê¸°í™”
    projectiles.clear()
    PROJECTILE_SPEED = 4

    # íƒ€ì´ë¨¸ë“¤ì„ 'í˜„ì¬' ì‹œê°ìœ¼ë¡œ ì´ˆê¸°í™”
    now = pygame.time.get_ticks()
    start_time = now
    last_spawn_time = now
    last_speed_increase_time = now
    last_parry_change_time = now

    # ê²Œì„/í”Œë ˆì´ì–´ ìƒíƒœ ì´ˆê¸°í™”
    parry_range = 120
    base_parry_range = parry_range
    range_reduced = False
    parry_color = (255, 255, 0)
    shake_start_time = 0

    score = 0
    hp = 5
    last_space_pressed = False
    last_parry_time = 0

    special_event_triggered = False

    # í”Œë ˆì´ì–´ ìœ„ì¹˜ë„ ì¤‘ì•™ìœ¼ë¡œ ì´ˆê¸°í™”
    player_pos = [WIDTH // 2, HEIGHT // 2]

    game_cleared = False
    game_over = False

    print("ğŸ” RESTART")

# ì´ˆê¸°í™” í˜¸ì¶œ
restart_game()

# ê²Œì„ ë£¨í”„
while running:
    dt = clock.tick(60)
    current_time = pygame.time.get_ticks()
    elapsed_time = (current_time - start_time) / 1000.0

    # ì´ë²¤íŠ¸ ì²˜ë¦¬
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

        # ê²Œì„ í´ë¦¬ì–´ ë˜ëŠ” ì˜¤ë²„ í›„ ë²„íŠ¼ í´ë¦­ ì²˜ë¦¬
        if (game_cleared or game_over) and event.type == pygame.MOUSEBUTTONDOWN:
            mx, my = event.pos
            try:
                if restart_button.collidepoint((mx, my)):
                    restart_game()
                elif quit_button.collidepoint((mx, my)):
                    running = False
            except NameError:
                pass

    # ê²Œì„ í´ë¦¬ì–´/ì˜¤ë²„ í™”ë©´
    if game_cleared or game_over:
        screen.blit(background, (0, 0))
        title_text = big_font.render("GAME CLEAR!" if game_cleared else "GAME OVER", True, YELLOW if game_cleared else RED)
        screen.blit(title_text, (WIDTH//2 - title_text.get_width()//2, HEIGHT//3))

        mouse_pos = pygame.mouse.get_pos()
        restart_button = draw_button("RESTART", WIDTH//2 - 150, HEIGHT//2, 130, 50, (0,150,0), (0,200,0), mouse_pos)
        quit_button = draw_button("QUIT", WIDTH//2 + 20, HEIGHT//2, 130, 50, (150,0,0), (200,0,0), mouse_pos)

        pygame.display.flip()
        continue

    keys = pygame.key.get_pressed()

    # 70ì´ˆê°€ ë˜ë©´ ê²Œì„ í´ë¦¬ì–´
    if elapsed_time >= 70:
        game_cleared = True
        print("ğŸ‰ GAME CLEAR!")
        continue

    # 10ì´ˆë§ˆë‹¤ ì†ë„ 10% ì¦ê°€
    if current_time - last_speed_increase_time >= SPEED_INCREASE_INTERVAL:
        PROJECTILE_SPEED *= 1.1
        last_speed_increase_time = current_time

    # 10ì´ˆ í›„ íŒ¨ë§ ë²”ìœ„ ê°ì†Œ
    if not range_reduced and elapsed_time >= 10:
        parry_range = int(parry_range * 0.8)
        base_parry_range = parry_range
        range_reduced = True

    # 20~40ì´ˆ ë™ì•ˆ íŒ¨ë§ ë²”ìœ„ ëœë¤(0.5 ~ 1.5ë°°) ë³€í™”
    if 20 <= elapsed_time <= 40:
        if current_time - last_parry_change_time >= 2000:
            scale = random.uniform(0.5, 1.5)
            parry_range = int(base_parry_range * scale)
            last_parry_change_time = current_time
            shake_start_time = current_time
            parry_color = (
                random.randint(100,255),
                random.randint(100,255),
                random.randint(100,255)
            )
    elif elapsed_time > 40:
        parry_range = base_parry_range
        parry_color = (255,255,0)

    # 60ì´ˆ ì´ë²¤íŠ¸ (í•œ ë²ˆë§Œ)
    if elapsed_time >= 60 and not special_event_triggered:
        directions = ["top","bottom","left","right"]
        for side in directions:
            for i in range(5):
                if side == "top":
                    x = 100 + i * (WIDTH - 200) / 4
                    y = -20
                elif side == "bottom":
                    x = 100 + i * (WIDTH - 200) / 4
                    y = HEIGHT + 20
                elif side == "left":
                    x = -20
                    y = 100 + i * (HEIGHT - 200) / 4
                else:
                    x = WIDTH + 20
                    y = 100 + i * (HEIGHT - 200) / 4

                dx = player_pos[0] - x
                dy = player_pos[1] - y
                dist = math.hypot(dx, dy) if (dx != 0 or dy != 0) else 1
                dx, dy = dx / dist, dy / dist

                projectiles.append({
                    "x": x, "y": y,
                    "dx": dx, "dy": dy,
                    "angle": random.randint(0,360),
                    "rotation_speed": random.uniform(2,6) * random.choice([-1,1]),
                    "trail": [],
                    "speed": random.uniform(*SPECIAL_PROJECTILE_SPEED_RANGE),
                    "reversed": False
                })
        special_event_triggered = True

    # ì¼ë°˜ íˆ¬ì‚¬ì²´ ìƒì„±
    if current_time - last_spawn_time > SPAWN_INTERVAL:
        side = random.choice(["top","bottom","left","right"])
        if side == "top":
            x, y = random.randint(0, WIDTH), 0
        elif side == "bottom":
            x, y = random.randint(0, WIDTH), HEIGHT
        elif side == "left":
            x, y = 0, random.randint(0, HEIGHT)
        else:
            x, y = WIDTH, random.randint(0, HEIGHT)

        dx = player_pos[0] - x
        dy = player_pos[1] - y
        dist = math.hypot(dx, dy) if (dx != 0 or dy != 0) else 1
        dx, dy = dx / dist, dy / dist

        projectiles.append({
            "x": x, "y": y,
            "dx": dx, "dy": dy,
            "reversed": False,
            "angle": random.randint(0,360),
            "rotation_speed": random.uniform(2,6) * random.choice([-1,1]),
            "trail": [],
            "speed": PROJECTILE_SPEED
        })
        last_spawn_time = current_time

    # ì´ë™ / íšŒì „ / íŠ¸ë ˆì¼ ê°±ì‹ 
    for p in projectiles:
        p["x"] += p["dx"] * p.get("speed", PROJECTILE_SPEED)
        p["y"] += p["dy"] * p.get("speed", PROJECTILE_SPEED)
        p["angle"] = (p["angle"] + p.get("rotation_speed", 0)) % 360
        p["trail"].append((p["x"], p["y"]))
        if len(p["trail"]) > 10:
            p["trail"].pop(0)

    # íŒ¨ë§ ì…ë ¥ ì²˜ë¦¬
    parry_pressed = keys[pygame.K_SPACE] and not last_space_pressed if (keys := pygame.key.get_pressed()) else False
    if parry_pressed and current_time - last_parry_time > PARRY_COOLDOWN:
        parry_success = False
        for p in projectiles:
            dist = math.hypot(p["x"] - player_pos[0], p["y"] - player_pos[1])
            if dist < parry_range and not p.get("reversed", False):
                p["dx"] *= -1
                p["dy"] *= -1
                p["reversed"] = True
                parry_success = True
                score += 1
        if not parry_success:
            hp -= 1
        last_parry_time = current_time
    # ë§ˆì§€ë§‰ ìŠ¤í˜ì´ìŠ¤ ìƒíƒœ ì €ì¥
    last_space_pressed = keys[pygame.K_SPACE]

    # ì¶©ëŒ ê²€ì‚¬
    for p in projectiles[:]:
        dist = math.hypot(p["x"] - player_pos[0], p["y"] - player_pos[1])
        if dist < (player_radius) and not p.get("reversed", False):
            hp -= 1
            projectiles.remove(p)

    # ë°°ê²½ ê·¸ë¦¬ê¸°
    screen.blit(background, (0, 0))
    # í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸°
    screen.blit(earth_image, (player_pos[0] - player_size//2, player_pos[1] - player_size//2))

    # ì§„ë™
    shake_offset = 0
    if pygame.time.get_ticks() - shake_start_time < SHAKE_DURATION:
        shake_offset = math.sin((pygame.time.get_ticks() - shake_start_time) * 0.05) * SHAKE_INTENSITY
    pygame.draw.circle(screen, parry_color, player_pos, int(parry_range + shake_offset), 2)

    # íŠ¸ë ˆì¼ ê·¸ë¦¬ê¸°
    for p in projectiles:
        for i, pos in enumerate(p["trail"]):
            if len(p["trail"]) == 0:
                continue
            alpha = int(255 * ((i / len(p["trail"])) ** 1.5))
            trail_surface = pygame.Surface((8,8), pygame.SRCALPHA)
            pygame.draw.circle(trail_surface, (255,200,50,alpha), (4,4), 4)
            screen.blit(trail_surface, (pos[0]-4, pos[1]-4))

    # ìš´ì„ ê·¸ë¦¬ê¸°
    for p in projectiles:
        rotated = pygame.transform.rotate(meteor_image, p["angle"])
        rotated = rotated.convert_alpha()
        rect = rotated.get_rect(center=(int(p["x"]), int(p["y"])))
        screen.blit(rotated, rect)

    # UI: Score, HP, Time, Speed
    screen.blit(font.render(f"Score: {score}", True, WHITE), (20, 20))
    screen.blit(font.render(f"HP: {hp}", True, WHITE), (20, 60))
    screen.blit(font.render(f"Time: {int(elapsed_time)}s", True, WHITE), (20, 100))
    screen.blit(font.render(f"Speed: {PROJECTILE_SPEED:.2f}", True, WHITE), (20, 140))

    # ê²Œì„ ì˜¤ë²„ ì²´í¬
    if hp <= 0:
        game_over = True
        continue

    pygame.display.flip()

pygame.quit()
sys.exit()
